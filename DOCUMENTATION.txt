URL Shortener Application - Comprehensive Documentation

Project Overview

This is a Spring Boot-based URL Shortener application with JWT authentication, PostgreSQL database, and REST API endpoints. The application allows users to register, login, create shortened URLs, and redirect via short codes.

---

1. Project Setup & Creation Commands

Initial Project Creation

# Using Spring Initializr (web-based)
# Visit: https://start.spring.io/

# Or using Maven command:
mvn archetype:generate -DgroupId=com.yato -DartifactId=urlShortenerb -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

# Or using Spring Boot CLI:
spring boot new --from https://start.spring.io --name=urlShortenerb --dependencies=data-jpa,security,validation,web,postgresql

Build & Run Commands

# Build the project
./mvnw clean package

# Run the application
./mvnw spring-boot:run

# Run tests
./mvnw test

# Skip tests during build
./mvnw clean package -DskipTests

# Package as JAR
./mvnw clean package -DskipTests
java -jar target/urlShortenerb-0.0.1-SNAPSHOT.jar

---

2. Project Dependencies & Structure

pom.xml - Maven Configuration

Key Dependencies:

- spring-boot-starter-data-jpa: ORM/Database access
- spring-boot-starter-security: Authentication & Authorization
- spring-boot-starter-web: REST API & Web MVC
- postgresql: Database Driver
- lombok: Reduce boilerplate code
- jjwt-api: JWT token generation
- springdoc-openapi-starter-webmvc-ui: Swagger/OpenAPI documentation

Build Plugins:
- Maven Compiler Plugin (Java 21 support)
- Spring Boot Maven Plugin (for creating executable JAR)

---

3. Configuration Files

src/main/resources/application.properties

# Application name
spring.application.name=urlShortenerb

# Server Configuration
server.port=8081

# PostgreSQL Database Configuration
spring.datasource.url=${POSTGRES_URL:jdbc:postgresql://localhost:5432/urlshortenerdb}
spring.datasource.username=${POSTGRES_USER:urluser}
spring.datasource.password=${POSTGRES_PASSWORD:urlpass}

# Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update      # Auto-create/update DB schema
spring.jpa.show-sql=true                   # Log SQL queries

# JWT Configuration
app.jwt.secret=YATO_SUPER_SECRET_KEY_1234567890!@#$%
app.jwt.expiration-ms=${JWT_EXPIRATION_MS:86400000}  # 24 hours

# Logging Configuration
logging.level.root=INFO
logging.level.com.urlshortener=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} %-5level [%thread] %logger{36} - %msg%n

# Swagger/OpenAPI
springdoc.api-docs.path=/v3/api-docs

---

4. Database Entities

src/main/java/com/yato/urlShortenerb/entity/User.java

Purpose: Represents a user in the system

Entity Name: users (Database Table)
Columns:
  - id (BIGINT, Primary Key, Auto-generated)
  - email (VARCHAR, Unique, Not Null)
  - password (VARCHAR, Not Null)

Methods:
- Getter/Setter methods (auto-generated by Lombok @Data)
- Constructor (auto-generated by @AllArgsConstructor and @NoArgsConstructor)

Annotations Used:
- @Entity - Marks as JPA entity
- @Table(name="users") - Maps to database table
- @Data - Generates getters, setters, toString, equals, hashCode
- @NoArgsConstructor - Generates no-arg constructor
- @AllArgsConstructor - Generates all-arg constructor

---

src/main/java/com/yato/urlShortenerb/entity/Url.java

Purpose: Represents a shortened URL mapping

Entity Name: urls (Database Table)
Columns:
  - id (BIGINT, Primary Key, Auto-generated)
  - user_id (BIGINT, Foreign Key to users)
  - shortCode (VARCHAR, Unique, Not Null)
  - longUrl (TEXT, Not Null)
  - clickCount (BIGINT, Default 0)
  - crtAt (TIMESTAMP, Creation time)
  - expiry (TIMESTAMP, Optional expiration time)

Methods:
- Getter/Setter methods (Lombok generated)
- Relationship: Many URLs to One User (@ManyToOne)

Annotations:
- @ManyToOne(fetch = FetchType.LAZY) - Lazy load user (performance optimization)
- @JoinColumn(name = "user_id") - Foreign key column
- @Column(unique = true, nullable = false) - Database constraints
- @ColumnDefinition("text") - Store long URLs as text type

---

5. Repository Layer

src/main/java/com/yato/urlShortenerb/repo/UserRepo.java

Purpose: Database access for User entity

public interface UserRepo extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

Methods:
- findByEmail(String email) - Custom query method to find user by email
  - Returns: Optional<User> (empty if not found)
  - Auto-implemented by Spring Data JPA

Inherited from JpaRepository:
- save(User user) - Create/Update user
- findById(Long id) - Find user by ID
- delete(User user) - Delete user
- findAll() - Get all users

---

src/main/java/com/yato/urlShortenerb/repo/UrlRepo.java

Purpose: Database access for URL entity

public interface UrlRepo extends JpaRepository<Url, Long> {
    Optional<Url> findByShortCode(String shortCode);
    List<Url> findByUserId(Long userId);
}

Custom Methods:
- findByShortCode(String shortCode) - Find URL by short code
- findByUserId(Long userId) - Find all URLs created by a user

Inherited Methods:
- save(Url url) - Create/Update URL
- findById(Long id) - Find URL by ID
- delete(Url url) - Delete URL

---

6. Service Layer

src/main/java/com/yato/urlShortenerb/service/UserService.java

Purpose: Interface defining user-related business logic

public interface UserService {
    ResponseEntity<?> register(RegisterRequest request);
    ResponseEntity<?> login(LoginRequest request);
}

Methods:
- register() - User registration logic
- login() - User login & JWT token generation

---

src/main/java/com/yato/urlShortenerb/service/impl/UserServiceImpl.java

Purpose: Implementation of UserService

Dependencies Injected:
- UserRepo - Database access
- BCryptPasswordEncoder - Password encryption
- JWTUtils - JWT token operations

Method: register(RegisterRequest request)
Steps:
1. Check if email already exists in database
2. If exists: return 400 Bad Request error
3. Create new User entity
4. Encode password using BCryptPasswordEncoder
5. Save user to database
6. Return 200 OK success message
7. Log all operations

Method: login(LoginRequest request)
Steps:
1. Find user by email in database
2. Check if user exists AND password matches (using BCryptPasswordEncoder.matches())
3. If invalid: return 401 Unauthorized
4. Generate JWT token using JWTUtils.generateToken()
5. Return token in AuthResponse
6. Log login success

---

src/main/java/com/yato/urlShortenerb/service/UserDetailsService.java

Purpose: Interface for loading user details (Spring Security integration)

public interface UserDetailsService {
    UserDetails loadUserByUsername(String email) throws UsernameNotFoundException;
}

---

src/main/java/com/yato/urlShortenerb/service/impl/UserDetailsServiceImpl.java

Purpose: Implementation for Spring Security user loading

Method: loadUserByUsername(String email)
Steps:
1. Find user by email using UserRepo
2. If not found: throw UsernameNotFoundException
3. Create Spring Security UserDetails object with:
   - email as username
   - encrypted password from database
   - List of authorities (ROLE_USER)
4. Return UserDetails for authentication

---

src/main/java/com/yato/urlShortenerb/service/UrlService.java

Purpose: Interface for URL shortening business logic

public interface UrlService {
    ResponseEntity<?> create(UrlRequest request, String currentUserEmail);
    ResponseEntity<?> getAll(String currentUserEmail);
    ResponseEntity<?> delete(Long id, String currentUserEmail);
    ResponseEntity<?> update(Long id, UrlRequest request, String currentUserEmail);
}

---

src/main/java/com/yato/urlShortenerb/service/impl/UrlServiceImpl.java

Purpose: Implementation of URL shortening operations

Dependencies:
- UrlRepo - URL database access
- UserRepo - User database access
- ShortCodeGenerator - Generate unique short codes

Method: create(UrlRequest request, String currentUserEmail)
Steps:
1. Find user by email in database
2. Create new Url entity
3. Set user association
4. Set long URL from request
5. Generate unique short code (loop until unique)
6. Set creation time to current time
7. If expiry provided in request: parse and set expiry date
8. Save URL to database
9. Return UrlResponse with ID, short code, long URL, click count
10. Log all operations

Method: getAll(String currentUserEmail)
Steps:
1. Find user by email
2. Fetch all URLs belonging to user using findByUserId()
3. Convert each Url entity to UrlResponse DTO
4. Return list of UrlResponse
5. Log fetch operation

Method: delete(Long id, String currentUserEmail)
Steps:
1. Check if currentUserEmail is valid
2. Find user by email
3. Find URL by ID
4. Verify URL belongs to current user (authorization check)
5. If unauthorized: return 403 Forbidden
6. Delete URL from database
7. Return success message
8. Log deletion

Method: update(Long id, UrlRequest request, String currentUserEmail)
Steps:
1. Find user by email
2. Find URL by ID
3. Verify authorization (URL belongs to user)
4. If longUrl provided in request: update it
5. If expiry provided:
   - Parse date using DateTimeFormatter
   - Set expiry date
   - Catch format errors: return 400 Bad Request
6. Save updated URL to database
7. Return success message

Method: generateUniqueCode()
Steps:
1. Generate short code using ShortCodeGenerator.generate()
2. Check if code already exists in database
3. If exists: regenerate (loop until unique)
4. Log generated code
5. Return unique code

---

7. Utility Classes

src/main/java/com/yato/urlShortenerb/util/ShortCodeGenerator.java

Purpose: Generate random short codes for URL shortening

Constants:
ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  - 62 total characters
DEFAULT_LENGTH = 7
  - Creates codes like: "aBc1234", "xYz9876"
RANDOM = SecureRandom()
  - Cryptographically secure random number generator

Method: generate()
Steps:
1. Create StringBuilder with capacity of 7
2. Loop 7 times:
   - Generate random index (0-61)
   - Get character from ALPHABET at that index
   - Append to StringBuilder
3. Return generated string
Result: 7-character random code from alphanumeric characters

---

8. Security Configuration

src/main/java/com/yato/urlShortenerb/config/SecurityConfig.java

Purpose: Configure Spring Security for JWT-based authentication

Configuration Details:

1. CSRF Protection: DISABLED
   - Stateless API doesn't need CSRF tokens

2. CORS Configuration:
   - Allowed Origins: http://localhost:5174, http://localhost:5173
   - Allowed Methods: GET, POST, PUT, DELETE, OPTIONS, PATCH
   - Allowed Headers: Authorization, Content-Type, Accept
   - Exposed Headers: Authorization
   - Credentials: Enabled
   - Max Age: 3600 seconds

3. Session Management:
   - Policy: STATELESS
   - No session cookies (JWT only)

4. Authorization Rules:
   - Public endpoints (No authentication required):
     * /auth/** (Register/Login)
     * /v3/api-docs/** (API documentation)
     * /swagger-ui/** (Swagger UI)
     * /s/{shortCode} (URL redirection)
   - All other endpoints: REQUIRE AUTHENTICATION

5. Filter Chain:
   - JwtAuthFilter added before UsernamePasswordAuthenticationFilter
   - Processes JWT tokens from Authorization header

Methods/Beans:

jwtAuthFilter() - Creates JWT authentication filter
filterChain(HttpSecurity http) - Configures security filter chain

---

src/main/java/com/yato/urlShortenerb/config/JWTUtils.java

Purpose: JWT token generation and validation

Configuration:
jwtSecret: YATO_SUPER_SECRET_KEY_1234567890!@#$%
jwtExpirationMs: 86400000 (24 hours)

Method: generateToken(String subject)
Steps:
1. Create JWT builder
2. Set subject (user email)
3. Set issued-at time to current time
4. Set expiration to current time + 24 hours
5. Sign with HMAC-SHA256 using secret key
6. Compact to string format
Return: JWT token string
Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

Method: getEmailFromToken(String token)
Steps:
1. Create JWT parser with signing key
2. Parse the JWT token
3. Extract claims (payload)
4. Get subject (stored as email)
Return: User email string
Throws: JwtException if token invalid/expired

Method: validateToken(String token)
Steps:
1. Try to parse JWT token
2. If successful: return true
3. If JwtException caught: return false
Validates: Signature, Expiration, Format

Method: getSigningKey()
Converts: Secret string to SecretKey using HMAC-SHA256
Used in: All token operations

---

src/main/java/com/yato/urlShortenerb/config/JwtAuthFilter.java

Purpose: Extract and validate JWT from each request

Extends: OncePerRequestFilter - Ensures filter runs once per request

Method: doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)
Steps:
1. Get Authorization header from request
2. Check if header exists and starts with "Bearer "
3. Extract token (substring from position 7)
4. Validate token using JWTUtils.validateToken()
5. If valid:
   a. Get email from token
   b. Load UserDetails using UserDetailsService
   c. Create UsernamePasswordAuthenticationToken
   d. Set in SecurityContext for this request
6. If invalid:
   a. Log debug message
   b. Continue without authentication
7. Continue filter chain

Flow Diagram:
Request with "Bearer {token}"
        ↓
Extract token
        ↓
Validate token signature & expiration
        ↓
Extract email from token
        ↓
Load user details from database
        ↓
Set SecurityContext authentication
        ↓
Continue to protected endpoint

---

src/main/java/com/yato/urlShortenerb/config/PasswordConfig.java

Purpose: Configure password encryption bean

Method: passwordEncoder()
Returns: BCryptPasswordEncoder instance
Used for: Password hashing with salt
Strength: 10 (default rounds of bcrypt hashing)

---

src/main/java/com/yato/urlShortenerb/config/CorsConfig.java

Purpose: Configure CORS (Cross-Origin Resource Sharing)

Method: addCorsMappings(CorsRegistry registry)
Configuration:
- Path: /** (all endpoints)
- Allowed Origins: localhost:5174, localhost:5173
- Methods: GET, POST, PUT, DELETE, OPTIONS, PATCH
- Headers: * (all)
- Credentials: true
- Max Age: 3600 seconds (browser cache)

---

9. Controller Layer

src/main/java/com/yato/urlShortenerb/controller/AuthController.java

Base Path: /auth

Endpoint: POST /auth/register
Request Body:
{
  "email": "user@example.com",
  "password": "securePassword123"
}

Process:
1. Create RegisterRequest DTO from JSON
2. Call userService.register()
3. Return response

Responses:
- 200 OK: "User registered"
- 400 Bad Request: "Email already exists"

Swagger Documentation:
@Operation(summary = "Register a new user")
@ApiResponses: Lists possible response codes

Endpoint: POST /auth/login
Request Body:
{
  "email": "user@example.com",
  "password": "securePassword123"
}

Process:
1. Create LoginRequest DTO from JSON
2. Call userService.login()
3. Return JWT token

Responses:
- 200 OK with JWT token
- 401 Unauthorized: "Invalid credentials"

Response Format:
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

---

src/main/java/com/yato/urlShortenerb/controller/UrlController.java

Base Path: /urls

Authentication: All endpoints require JWT token in Authorization: Bearer {token} header

Helper Method: currentUserEmail()
Purpose: Extract current user email from security context
Steps:
1. Get authentication from SecurityContextHolder
2. Extract principal from authentication
3. Check if principal is UserDetails instance
4. Return username (email)
Return: String email of authenticated user

Endpoint: POST /urls/create
Request Body:
{
  "longUrl": "https://example.com/very/long/url",
  "expiry": "2025-12-31T23:59:00"  // optional
}

Process:
1. Extract current user email from security context
2. Call urlService.create(request, email)
3. Return shortened URL details

Response (200):
{
  "id": 1,
  "shortCode": "aBc1234",
  "longUrl": "https://example.com/very/long/url",
  "clickCount": 0
}

DTOs Used: UrlRequest, UrlResponse

Endpoint: GET /urls/all
Purpose: Get all URLs created by authenticated user

Process:
1. Extract current user email
2. Call urlService.getAll(email)
3. Return list of user's URLs

Response (200):
[
  {
    "id": 1,
    "shortCode": "aBc1234",
    "longUrl": "https://example.com/...",
    "clickCount": 5
  },
  ...
]

DTO: List<UrlResponse>

Endpoint: DELETE /urls/delete/{id}
Path Parameter: id (Long) - URL ID to delete

Process:
1. Extract Authorization header
2. Validate header format (Bearer token)
3. Extract token substring
4. Get email from token using JWTUtils.getEmailFromToken()
5. Validate email is not null
6. Call urlService.delete(id, email)
7. Return response

Responses:
- 200 OK: "Deleted"
- 401: "Missing/invalid token" or "Invalid or expired token"
- 403: "Forbidden" (URL doesn't belong to user)
- 404: "URL not found"

Endpoint: POST /urls/update/{id}
Path Parameter: id (Long) - URL ID to update
Request Body:
{
  "longUrl": "https://new-url.com",
  "expiry": "2025-12-31T23:59"
}

Process:
1. Extract Authorization header
2. Validate and extract token
3. Get email from token
4. Validate email
5. Call urlService.update(id, request, email)
6. Return response

Responses:
- 200 OK: "URL updated successfully"
- 400: "Invalid expiry format"
- 401: "Missing/invalid token"
- 403: "Forbidden"
- 404: "URL not found"

---

src/main/java/com/yato/urlShortenerb/controller/RedirectController.java

Purpose: Handle short URL redirections (public endpoint)

Endpoint: GET /s/{shortCode}
Path Parameter: shortCode (String) - 7-character short code

Process:
1. Find URL by short code using urlRepo
2. If not found: return 400 error
3. Increment clickCount
4. Save updated URL to database
5. Return 302 redirect to original longUrl

Example:
GET /s/aBc1234
↓
Look up short code in database
↓
Found: points to "https://example.com/original/url"
↓
Increment click count
↓
HTTP 302 Response with Location header
↓
Browser redirects to original URL

Response Headers:
- Status: 302 Found
- Location: https://example.com/original/url

Error (400):
"Invalid short URL"

Features:
- Tracks click count for analytics
- No authentication required (public)
- Automatically redirects to original URL
- HTTP 302 status (temporary redirect)

---

10. Data Transfer Objects (DTOs)

src/main/java/com/yato/urlShortenerb/dto/RegisterRequest.java

public record RegisterRequest(String email, String password) {}

Purpose: Encapsulate registration form data
Fields:
- email - User email address
- password - User password (will be encrypted)

Advantages of Record:
- Immutable
- Auto-generated getters
- Auto-generated equals(), hashCode(), toString()
- Concise syntax

src/main/java/com/yato/urlShortenerb/dto/LoginRequest.java

public record LoginRequest(String email, String password) {}

Purpose: Encapsulate login credentials

src/main/java/com/yato/urlShortenerb/dto/AuthResponse.java

public record AuthResponse(String token) {}

Purpose: Return JWT token after successful login

src/main/java/com/yato/urlShortenerb/dto/UrlRequest.java

public record UrlRequest(String longUrl, String expiry) {}

Purpose: Request data for creating/updating shortened URLs
Fields:
- longUrl - Original URL to shorten
- expiry - Optional expiration date (ISO format: "2025-12-31T23:59:00")

src/main/java/com/yato/urlShortenerb/dto/UrlResponse.java

public record UrlResponse(
  Long id,
  @JsonProperty("shortCode")
  String shortcode,
  @JsonProperty("longUrl")
  String longUrl,
  @JsonProperty("clickCount")
  Long clickcount
) {}

Purpose: Return shortened URL details to client

JSON Property Mapping:
- shortcode → JSON field shortCode
- longUrl → JSON field longUrl
- clickcount → JSON field clickCount

Response Example:
{
  "id": 1,
  "shortCode": "aBc1234",
  "longUrl": "https://example.com/very/long/url",
  "clickCount": 5
}

---

11. Exception Handling

src/main/java/com/yato/urlShortenerb/exception/GlobalExceptionHandler.java

Purpose: Centralized exception handling across application

Annotation: @RestControllerAdvice - Applies to all REST controllers

Method: handleAll(Exception ex)
Handles: Any Exception not specifically handled
Parameters: Exception ex - The thrown exception
Returns: ResponseEntity with 500 status and error message
Process:
1. Log error with full stack trace
2. Return generic error response
3. Prevents exposing internal details to client

Response (500):
{
  "message": "Internal Server Error"
}

Better Practice: Create specific exception handlers
@ExceptionHandler(UsernameNotFoundException.class)
@ExceptionHandler(RuntimeException.class)
etc.

---

12. Testing

src/test/java/com/yato/urlShortenerb/UrlShortenerbApplicationTests.java

Purpose: Test Spring Boot application startup

@SpringBootTest
class UrlShortenerbApplicationTests {
    @Test
    void contextLoads() {
        // Tests if Spring context loads successfully
    }
}

Annotations:
- @SpringBootTest - Load full Spring context for integration testing
- @Test - Mark method as test case (JUnit 5)

Test Execution:
./mvnw test

# Run specific test class
./mvnw test -Dtest=UrlShortenerbApplicationTests

# Run specific test method
./mvnw test -Dtest=UrlShortenerbApplicationTests#contextLoads

# With coverage report
./mvnw test jacoco:report

---

13. Complete API Flow Examples

User Registration & Login Flow

1. User Registration
   POST /auth/register
   {
     "email": "john@example.com",
     "password": "secure123"
   }
   ↓
   UserServiceImpl.register():
   - Check if email exists
   - Encode password with BCrypt
   - Save User to database
   ↓
   Response: 200 OK "User registered"

2. User Login
   POST /auth/login
   {
     "email": "john@example.com",
     "password": "secure123"
   }
   ↓
   UserServiceImpl.login():
   - Find user by email
   - Verify password with BCrypt
   - Generate JWT token (24 hour expiry)
   ↓
   Response: 200 OK
   {
     "token": "eyJhbGc..."
   }

3. Using Token
   GET /urls/all
   Header: Authorization: Bearer eyJhbGc...
   ↓
   JwtAuthFilter.doFilterInternal():
   - Extract token from header
   - Validate signature & expiration
   - Extract email from token
   - Load user details
   - Set authentication in security context
   ↓
   UrlController.getAll():
   - Get authenticated user email
   - Fetch user's URLs
   - Return list

URL Shortening & Redirection Flow

1. Create Short URL
   POST /urls/create
   Authorization: Bearer {token}
   {
     "longUrl": "https://example.com/very/long/url/path",
     "expiry": "2025-12-31T23:59"
   }
   ↓
   UrlServiceImpl.create():
   - Find user by email
   - Generate unique 7-char code
   - Save URL with metadata
   ↓
   Response: 200 OK
   {
     "id": 1,
     "shortCode": "aBc1234",
     "longUrl": "https://example.com/...",
     "clickCount": 0
   }

2. Share Short URL
   User shares: https://yourdomain.com/s/aBc1234

3. Redirect Using Short Code
   GET /s/aBc1234
   ↓
   RedirectController.redirect():
   - Find URL by short code
   - Increment click count
   - Save to database
   - Return 302 redirect
   ↓
   Response: HTTP 302
   Location: https://example.com/very/long/url/path
   ↓
   Browser automatically redirects to original URL

---

14. Database Schema

-- Users Table
CREATE TABLE users (
  id BIGSERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL
);

-- URLs Table
CREATE TABLE urls (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL,
  short_code VARCHAR(255) NOT NULL UNIQUE,
  long_url TEXT NOT NULL,
  click_count BIGINT DEFAULT 0,
  crt_at TIMESTAMP,
  expiry TIMESTAMP,
  CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Indexes for performance
CREATE INDEX idx_urls_short_code ON urls(short_code);
CREATE INDEX idx_urls_user_id ON urls(user_id);
CREATE INDEX idx_users_email ON users(email);

---

15. Creating New Components/Pages

Command to Create New Controller

# Create new controller
mkdir -p src/main/java/com/yato/urlShortenerb/controller/api

# Create file: ApiController.java
cat > src/main/java/com/yato/urlShortenerb/controller/api/ApiController.java << 'EOF'
package com.yato.urlShortenerb.controller.api;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
@RequestMapping("/api/endpoint")
@RequiredArgsConstructor
public class ApiController {
    
    @GetMapping
    public String getEndpoint() {
        return "Response";
    }
}
EOF

Command to Create New Service

# Create service interface
cat > src/main/java/com/yato/urlShortenerb/service/CustomService.java << 'EOF'
package com.yato.urlShortenerb.service;

public interface CustomService {
    // Define methods
}
EOF

# Create service implementation
cat > src/main/java/com/yato/urlShortenerb/service/impl/CustomServiceImpl.java << 'EOF'
package com.yato.urlShortenerb.service.impl;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CustomServiceImpl implements CustomService {
    // Implement methods
}
EOF

Command to Create New Entity

cat > src/main/java/com/yato/urlShortenerb/entity/CustomEntity.java << 'EOF'
package com.yato.urlShortenerb.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name="custom_entities")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CustomEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
}
EOF

Command to Create New Repository

cat > src/main/java/com/yato/urlShortenerb/repo/CustomRepo.java << 'EOF'
package com.yato.urlShortenerb.repo;

import com.yato.urlShortenerb.entity.CustomEntity;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CustomRepo extends JpaRepository<CustomEntity, Long> {
    // Custom query methods
}
EOF

Command to Create New DTO

cat > src/main/java/com/yato/urlShortenerb/dto/CustomRequest.java << 'EOF'
package com.yato.urlShortenerb.dto;

public record CustomRequest(String field1, String field2) {}
EOF

---

16. Running the Application Locally

Prerequisites

- Java 21+
- PostgreSQL 12+
- Maven 3.8+

Recommended

- Git
- IDE (IntelliJ IDEA, VS Code)
- Postman (API testing)

Setup Database

# Create PostgreSQL database
createdb urlshortenerdb

# Create user with password
psql -U postgres -c "CREATE USER urluser WITH PASSWORD 'urlpass';"
psql -U postgres -c "ALTER USER urluser CREATEDB;"
psql -U postgres -c "GRANT ALL PRIVILEGES ON DATABASE urlshortenerdb TO urluser;"

Run Application

# Clone repository
git clone <repo-url>
cd urlShortenerb

# Install dependencies
./mvnw clean install

# Run application
./mvnw spring-boot:run

# Application available at:
# http://localhost:8081
# Swagger UI: http://localhost:8081/swagger-ui.html
# API Docs: http://localhost:8081/v3/api-docs

Environment Variables

export POSTGRES_URL=jdbc:postgresql://localhost:5432/urlshortenerdb
export POSTGRES_USER=urluser
export POSTGRES_PASSWORD=urlpass
export JWT_EXPIRATION_MS=86400000

---

17. NEW FEATURES

Feature 1: Analytics & Click Tracking

src/main/java/com/yato/urlShortenerb/entity/AnalyticsEvent.java

Purpose: Track individual click events with metadata

Entity Name: analytics_events
Columns:
  - id (BIGINT, Primary Key)
  - url_id (BIGINT, Foreign Key to urls)
  - user_agent (VARCHAR) - Browser/device info
  - ip_address (VARCHAR) - Visitor IP
  - referrer (VARCHAR) - HTTP referrer
  - clicked_at (TIMESTAMP) - When URL was clicked
  - country (VARCHAR) - Geo-location country
  - device_type (VARCHAR) - Mobile/Desktop/Tablet

src/main/java/com/yato/urlShortenerb/repo/AnalyticsEventRepo.java

Custom Methods:
- findByUrlId(Long urlId) - Get all clicks for a URL
- countByUrlIdAndClickedAtBetween(Long urlId, LocalDateTime start, LocalDateTime end)
  - Count clicks within date range
- findByUrlIdOrderByClickedAtDesc(Long urlId) - Get recent clicks

src/main/java/com/yato/urlShortenerb/service/AnalyticsService.java

Interface Methods:
- recordClick(String shortCode, HttpServletRequest request) - Log new click
- getAnalytics(Long urlId) - Get analytics dashboard data
- getClicksByDateRange(Long urlId, LocalDateTime start, LocalDateTime end)
  - Get clicks in specific period

src/main/java/com/yato/urlShortenerb/service/impl/AnalyticsServiceImpl.java

Method: recordClick(String shortCode, HttpServletRequest request)
Steps:
1. Find URL by short code
2. Extract from request:
   - User-Agent (browser info)
   - Client IP address
   - Referrer header
   - Parse device type from User-Agent
3. Optional: Geo-locate IP using MaxMind or IP geolocation API
4. Create AnalyticsEvent entity
5. Save to database
6. Increment URL click count

Endpoint: GET /analytics/{urlId}
Authentication: Required (owner only)
Response:
{
  "urlId": 1,
  "shortCode": "aBc1234",
  "totalClicks": 45,
  "uniqueVisitors": 32,
  "avgClicksPerDay": 3.2,
  "topReferrers": ["google.com", "twitter.com"],
  "deviceBreakdown": {
    "mobile": 25,
    "desktop": 18,
    "tablet": 2
  },
  "countriesData": [
    {"country": "US", "clicks": 20},
    {"country": "IN", "clicks": 15}
  ]
}

---

Feature 2: URL Expiration & Automatic Cleanup

Expiration Logic in Url Entity:

@Column(name = "expiry")
private LocalDateTime expiry;

Database Query Optimization:
- Index on expiry column for fast filtering
- Scheduled task to delete expired URLs

Scheduled Task Implementation:

@Component
public class UrlExpirationTask {
    
    @Scheduled(cron = "0 0 * * * *")  // Every hour
    public void deleteExpiredUrls() {
        List<Url> expiredUrls = urlRepo.findByExpiryBefore(LocalDateTime.now());
        expiredUrls.forEach(url -> {
            analyticsEventRepo.deleteByUrlId(url.getId());
            urlRepo.delete(url);
        });
        log.info("Deleted {} expired URLs", expiredUrls.size());
    }
}

RedirectController Enhancement:

Method: redirect(String shortCode)
Steps:
1. Find URL by short code
2. Check if URL has expiry date
3. If expired: return 410 Gone (Permanently unavailable)
4. If not expired: proceed with redirect
5. Record analytics event

Response for expired URL (410):
{
  "error": "URL expired",
  "expiredAt": "2025-12-31T23:59:00"
}

---

Feature 3: Bulk URL Operations

New Endpoints:

POST /urls/bulk/create
Purpose: Create multiple shortened URLs in one request

Request Body:
{
  "urls": [
    {
      "longUrl": "https://example1.com",
      "title": "Example 1",
      "expiry": "2025-12-31T23:59"
    },
    {
      "longUrl": "https://example2.com",
      "title": "Example 2"
    }
  ]
}

Response (200):
{
  "created": 2,
  "results": [
    {
      "longUrl": "https://example1.com",
      "shortCode": "aBc1234",
      "status": "success"
    },
    {
      "longUrl": "https://example2.com",
      "shortCode": "xYz5678",
      "status": "success"
    }
  ]
}

DELETE /urls/bulk/delete
Request Body:
{
  "ids": [1, 2, 3]
}

Response (200):
{
  "deleted": 3,
  "message": "Successfully deleted 3 URLs"
}

POST /urls/bulk/export
Export all user URLs as JSON or CSV

---

Feature 4: API Rate Limiting

Implementation using Spring Cloud Gateway or Bucket4j:

Configuration in SecurityConfig:

@Bean
public RateLimiter rateLimiter() {
    return new RateLimiter(
        requestsPerMinute: 60,
        requestsPerHour: 1000,
        requestsPerDay: 10000
    );
}

Rate Limit Headers in Response:

X-RateLimit-Limit: 60
X-RateLimit-Remaining: 55
X-RateLimit-Reset: 1702563780

Error Response (429):
{
  "error": "Too Many Requests",
  "message": "Rate limit exceeded: 60 requests per minute",
  "retryAfter": 45
}

Rate Limits by Endpoint:
- POST /auth/register: 5 requests per hour
- POST /auth/login: 10 requests per hour
- POST /urls/create: 100 requests per day
- GET /urls/all: 60 requests per minute
- GET /s/{shortCode}: Unlimited (public)

---

Feature 5: Caching Strategy

Redis Caching Implementation:

Dependencies:
- spring-boot-starter-data-redis
- jedis (or lettuce)

Configuration in application.properties:

spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
spring.cache.redis.time-to-live=3600000

Caching Annotations:

@Cacheable(value = "url", key = "#shortCode", unless = "#result == null")
public Url findByShortCode(String shortCode) {
    return urlRepo.findByShortCode(shortCode);
}

@CacheEvict(value = "url", key = "#shortCode")
public void updateUrl(String shortCode, UrlRequest request) {
    // Update logic
}

Cached Data:
- Short Code → URL mapping (most frequently accessed)
- User → URLs list (expires after 30 minutes)
- Analytics summaries (expires after 1 hour)

Cache Hit Benefits:
- Redirect response time: 5-10ms (vs 50-100ms without cache)
- Database load reduction: 70-80% for redirects
- Analytics aggregation queries are pre-computed

---

Feature 6: QR Code Generation

New Endpoint: GET /urls/{id}/qrcode
Response: PNG image of QR code

Implementation:

Dependencies:
- com.google.zxing:core
- com.google.zxing:javase

Service Method:

@Service
public class QrCodeService {
    
    public BufferedImage generateQRCode(String shortUrl, int width, int height) 
        throws WriterException {
        QRCodeWriter qrCodeWriter = new QRCodeWriter();
        BitMatrix bitMatrix = qrCodeWriter.encode(
            shortUrl, 
            BarcodeFormat.QR_CODE, 
            width, 
            height
        );
        return MatrixToImageWriter.toBufferedImage(bitMatrix);
    }
}

Controller Endpoint:

@GetMapping("/{id}/qrcode")
public ResponseEntity<byte[]> getQRCode(
    @PathVariable Long id,
    @RequestParam(defaultValue = "300") int size
) {
    Url url = urlService.getUrl(id);
    BufferedImage qrImage = qrCodeService.generateQRCode(
        "https://yourdomain.com/s/" + url.getShortCode(),
        size,
        size
    );
    
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ImageIO.write(qrImage, "png", baos);
    
    return ResponseEntity.ok()
        .contentType(MediaType.IMAGE_PNG)
        .body(baos.toByteArray());
}

Usage:
- Display QR code in analytics dashboard
- Allow users to download QR code for print materials
- Share QR code on social media

---

Feature 7: Custom Short Codes (Vanity URLs)

New Endpoint: POST /urls/custom
Request Body:
{
  "longUrl": "https://example.com/very/long/url",
  "customCode": "mycode123",
  "expiry": "2025-12-31T23:59"
}

Validation:
- Custom code 3-50 characters alphanumeric
- Must not already exist
- Cannot contain reserved words (/auth, /admin, etc.)
- Must pass regex: ^[a-zA-Z0-9_-]{3,50}$

Service Method:

public ResponseEntity<?> createCustomUrl(UrlRequest request, String customCode) {
    // Validate custom code
    if (!isValidCustomCode(customCode)) {
        return ResponseEntity.badRequest().body("Invalid custom code");
    }
    
    // Check if code already taken
    if (urlRepo.findByShortCode(customCode).isPresent()) {
        return ResponseEntity.status(409).body("Custom code already taken");
    }
    
    // Create URL with custom code
    Url url = new Url();
    url.setShortCode(customCode);
    // ... set other fields
    urlRepo.save(url);
    
    return ResponseEntity.ok(new UrlResponse(...));
}

---

Feature 8: URL Tags & Categories

New Entity: UrlTag

@Entity
@Table(name = "url_tags")
public class UrlTag {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    @Column(unique = true)
    private String name;
    
    @ManyToMany(mappedBy = "tags")
    private Set<Url> urls = new HashSet<>();
}

Updated Url Entity:

@ManyToMany
@JoinTable(
    name = "url_tags_mapping",
    joinColumns = @JoinColumn(name = "url_id"),
    inverseJoinColumns = @JoinColumn(name = "tag_id")
)
private Set<UrlTag> tags = new HashSet<>();

New Endpoints:

POST /tags/create
{
  "name": "social-media",
  "color": "#FF5733"
}

GET /urls/filter?tags=social-media,marketing

DELETE /tags/{tagId}

---

Feature 9: User Subscription Plans

New Entity: Subscription

@Entity
@Table(name = "subscriptions")
public class Subscription {
    @Id
    private Long id;
    
    @OneToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    @Enumerated(EnumType.STRING)
    private PlanType plan; // FREE, BASIC, PREMIUM, ENTERPRISE
    
    private Integer urlsLimit;
    private Integer analyticsRetention; // days
    private Boolean customDomainsAllowed;
    private Boolean apiAccessAllowed;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
}

Plan Features:

FREE:
- URLs limit: 10
- Analytics retention: 7 days
- Custom codes: No
- API access: No

BASIC:
- URLs limit: 100
- Analytics retention: 30 days
- Custom codes: Yes
- API access: Yes
- Price: $5/month

PREMIUM:
- URLs limit: 1000
- Analytics retention: 365 days
- Custom codes: Yes
- API access: Yes
- Custom domains: Yes
- Price: $15/month

ENTERPRISE:
- Unlimited URLs
- Unlimited analytics retention
- Custom domains
- Priority support
- Custom price

Service Validation:

@Service
public class SubscriptionService {
    
    public boolean canCreateUrl(User user) {
        Subscription sub = user.getSubscription();
        int urlCount = urlRepo.countByUserId(user.getId());
        return urlCount < sub.getUrlsLimit();
    }
    
    public List<AnalyticsEvent> getAnalyticsWithinRetention(Long urlId) {
        User user = urlRepo.findById(urlId).get().getUser();
        int retentionDays = user.getSubscription().getAnalyticsRetention();
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(retentionDays);
        return analyticsEventRepo.findByUrlIdAndClickedAtAfter(urlId, cutoffDate);
    }
}

---

Feature 10: API Documentation & Webhooks

Webhook Support:

New Entity: Webhook

@Entity
@Table(name = "webhooks")
public class Webhook {
    @Id
    @GeneratedValue
    private Long id;
    
    @ManyToOne
    private User user;
    
    private String callbackUrl;
    
    @Enumerated(EnumType.STRING)
    private WebhookEvent event; // URL_CREATED, URL_CLICKED, URL_DELETED
    
    private Boolean active;
    private LocalDateTime createdAt;
}

Webhook Events:

// Event: URL_CREATED
{
  "event": "url.created",
  "timestamp": "2025-12-14T10:30:00Z",
  "data": {
    "id": 1,
    "shortCode": "aBc1234",
    "longUrl": "https://example.com",
    "userId": 5
  }
}

// Event: URL_CLICKED
{
  "event": "url.clicked",
  "timestamp": "2025-12-14T10:35:00Z",
  "data": {
    "shortCode": "aBc1234",
    "ipAddress": "192.168.1.1",
    "userAgent": "Mozilla/5.0...",
    "country": "US"
  }
}

Implementation:

@Service
public class WebhookService {
    
    public void triggerWebhook(WebhookEvent event, Object data) {
        List<Webhook> webhooks = webhookRepo.findByEventAndActive(event, true);
        
        for (Webhook webhook : webhooks) {
            try {
                webClient.post()
                    .uri(webhook.getCallbackUrl())
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(new WebhookPayload(event, data))
                    .retrieve()
                    .toBodilessEntity()
                    .subscribe();
            } catch (Exception e) {
                log.error("Webhook failed for: {}", webhook.getId(), e);
            }
        }
    }
}

---

18. Project Structure Summary

urlShortenerb/
├── src/
│   ├── main/
│   │   ├── java/com/yato/urlShortenerb/
│   │   │   ├── entity/              # JPA entities
│   │   │   │   ├── User.java
│   │   │   │   └── Url.java
│   │   │   ├── repo/                # Repository interfaces
│   │   │   │   ├── UserRepo.java
│   │   │   │   └── UrlRepo.java
│   │   │   ├── service/             # Business logic interfaces
│   │   │   │   ├── UserService.java
│   │   │   │   ├── UrlService.java
│   │   │   │   └── UserDetailsService.java
│   │   │   ├── service/impl/        # Service implementations
│   │   │   │   ├── UserServiceImpl.java
│   │   │   │   ├── UrlServiceImpl.java
│   │   │   │   └── UserDetailsServiceImpl.java
│   │   │   ├── controller/          # REST endpoints
│   │   │   │   ├── AuthController.java
│   │   │   │   ├── UrlController.java
│   │   │   │   └── RedirectController.java
│   │   │   ├── config/              # Spring configuration
│   │   │   │   ├── SecurityConfig.java
│   │   │   │   ├── JWTUtils.java
│   │   │   │   ├── JwtAuthFilter.java
│   │   │   │   ├── PasswordConfig.java
│   │   │   │   └── CorsConfig.java
│   │   │   ├── dto/                 # Data transfer objects
│   │   │   │   ├── RegisterRequest.java
│   │   │   │   ├── LoginRequest.java
│   │   │   │   ├── AuthResponse.java
│   │   │   │   ├── UrlRequest.java
│   │   │   │   └── UrlResponse.java
│   │   │   ├── util/                # Utility classes
│   │   │   │   └── ShortCodeGenerator.java
│   │   │   ├── exception/           # Exception handlers
│   │   │   │   └── GlobalExceptionHandler.java
│   │   │   └── UrlShortenerbApplication.java  # Main entry point
│   │   └── resources/
│   │       └── application.properties  # Configuration
│   └── test/
│       └── java/com/yato/urlShortenerb/
│           └── UrlShortenerbApplicationTests.java
├── pom.xml                          # Maven dependencies
├── .gitignore
└── README.md

---

This comprehensive documentation covers all major components, their interactions, methods, and provides commands for creating new features and running the application.
